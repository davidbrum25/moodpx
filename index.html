<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moodpx - AI Pixel Art Fixer</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Import Map for React & Lucide -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1"
      }
    }
    </script>

    <!-- Babel for JSX compilation in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <link rel="icon" href="https://raw.githubusercontent.com/davidbrum25/moodsprite/refs/heads/main/moodsprite_fav_icon_alternative.png" type="image/png">

    <style>
        /* Dark mode scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #09090b;
        }
        ::-webkit-scrollbar-thumb {
            background: #27272a;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #3f3f46;
        }

        /* Disable touch actions for the canvas container to prevent scrolling while interacting */
        .touch-none {
            touch-action: none;
        }
    </style>
</head>
<body class="bg-black text-zinc-300 overflow-x-hidden">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Upload, Download, Image as ImageIcon, RefreshCw, Palette, Layers, Maximize2, Github, Link as LinkIcon, ZoomIn, ZoomOut, Maximize as ResetZoom, Frame } from 'lucide-react';

        // --- Constants & Types ---

        const PRESET_RESOLUTIONS = [
            { label: '32px', value: 32 },
            { label: '64px', value: 64 },
            { label: '128px', value: 128 },
            { label: '256px', value: 256 },
            { label: '512px', value: 512 },
        ];

        const COLOR_COUNTS = [2, 4, 8, 12, 16, 24, 32, 48, 64, 128, 256];

        // --- Icons ---
        const PatreonIcon = ({ className }) => (
            <svg viewBox="0 0 24 24" fill="currentColor" className={className} xmlns="http://www.w3.org/2000/svg">
                <path d="M15.386 6.226C13.065 6.226 11.2 8.12 11.2 10.457c0 2.338 1.865 4.23 4.186 4.23 2.32 0 4.186-1.892 4.186-4.23 0-2.338-1.866-4.231-4.186-4.231zM0 17.588h4.08V0H0v17.588z"/>
            </svg>
        );

        // --- Helper Functions ---

        const colorDistanceSq = (c1, c2) => {
            return (
                (c1.r - c2.r) ** 2 +
                (c1.g - c2.g) ** 2 +
                (c1.b - c2.b) ** 2 +
                (c1.a - c2.a) ** 2
            );
        };

        const quantizeColors = (imageData, k) => {
            const data = imageData.data;
            const pixelCount = data.length / 4;
            const pixels = [];
            const validIndices = [];

            for (let i = 0; i < pixelCount; i++) {
                const offset = i * 4;
                const a = data[offset + 3];
                if (a > 10) {
                    pixels.push({
                        r: data[offset],
                        g: data[offset + 1],
                        b: data[offset + 2],
                        a: a
                    });
                    validIndices.push(i);
                }
            }

            if (pixels.length === 0 || k >= pixels.length) return imageData;

            let centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push(pixels[Math.floor(Math.random() * pixels.length)]);
            }

            const iterations = 5;
            for (let iter = 0; iter < iterations; iter++) {
                const clusters = Array.from({ length: k }, () => []);
                for (let p of pixels) {
                    let minDist = Infinity;
                    let clusterIndex = 0;
                    for (let i = 0; i < k; i++) {
                        const dist = colorDistanceSq(p, centroids[i]);
                        if (dist < minDist) {
                            minDist = dist;
                            clusterIndex = i;
                        }
                    }
                    clusters[clusterIndex].push(p);
                }

                const newCentroids = [];
                let changed = false;
                for (let i = 0; i < k; i++) {
                    const cluster = clusters[i];
                    if (cluster.length === 0) {
                        newCentroids.push(centroids[i]);
                        continue;
                    }
                    const sum = cluster.reduce(
                        (acc, p) => ({ r: acc.r + p.r, g: acc.g + p.g, b: acc.b + p.b, a: acc.a + p.a }),
                        { r: 0, g: 0, b: 0, a: 0 }
                    );
                    const newC = {
                        r: Math.round(sum.r / cluster.length),
                        g: Math.round(sum.g / cluster.length),
                        b: Math.round(sum.b / cluster.length),
                        a: Math.round(sum.a / cluster.length),
                    };
                    if (colorDistanceSq(newC, centroids[i]) > 0) changed = true;
                    newCentroids.push(newC);
                }
                centroids = newCentroids;
                if (!changed) break;
            }

            const result = new ImageData(new Uint8ClampedArray(data), imageData.width, imageData.height);
            for (let i = 0; i < validIndices.length; i++) {
                const idx = validIndices[i];
                const offset = idx * 4;
                const p = pixels[i];
                let minDist = Infinity;
                let nearestCentroid = centroids[0];
                for (let c of centroids) {
                    const dist = colorDistanceSq(p, c);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestCentroid = c;
                    }
                }
                result.data[offset] = nearestCentroid.r;
                result.data[offset + 1] = nearestCentroid.g;
                result.data[offset + 2] = nearestCentroid.b;
                result.data[offset + 3] = nearestCentroid.a;
            }

            for(let i=0; i<pixelCount; i++) {
                const offset = i*4;
                if(result.data[offset+3] <= 10) {
                    result.data[offset] = 0;
                    result.data[offset+1] = 0;
                    result.data[offset+2] = 0;
                    result.data[offset+3] = 0;
                }
            }
            return result;
        };

        // --- Main Component ---

        function MoodpxApp() {
            // Image State
            const [originalImage, setOriginalImage] = useState(null);
            const [processedImageSrc, setProcessedImageSrc] = useState(null);
            const [originalSrc, setOriginalSrc] = useState(null);

            // Settings State
            const [targetWidth, setTargetWidth] = useState(64);
            const [maintainAspect, setMaintainAspect] = useState(true);
            const [colorCount, setColorCount] = useState(16);

            // UI State
            const [isProcessing, setIsProcessing] = useState(false);
            const [isDragging, setIsDragging] = useState(false);

            // Zoom & Pan State (Output)
            const [zoom, setZoom] = useState(1);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = useState(false);

            // Refs
            const canvasRef = useRef(null);
            const outputContainerRef = useRef(null);
            const lastMousePos = useRef({ x: 0, y: 0 });
            const lastTouchDistance = useRef(null);

            // --- Handlers ---

            const handleImageLoad = (src) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    setOriginalImage(img);
                    setOriginalSrc(src);
                    if (img.width > 128) {
                        setTargetWidth(128);
                    } else {
                        setTargetWidth(img.width);
                    }
                    // Reset zoom/pan on new image
                    setTimeout(handleFitToScreen, 100);
                };
                img.src = src;
            };

            const handleFileUpload = (e) => {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        if (ev.target?.result) handleImageLoad(ev.target.result);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            };

            const handlePaste = useCallback((e) => {
                const items = e.clipboardData?.items;
                if (!items) return;
                for (const item of items) {
                    if (item.type.indexOf('image') !== -1) {
                        const blob = item.getAsFile();
                        if (blob) {
                            const reader = new FileReader();
                            reader.onload = (ev) => {
                                if (ev.target?.result) handleImageLoad(ev.target.result);
                            };
                            reader.readAsDataURL(blob);
                        }
                    }
                }
            }, []);

            useEffect(() => {
                window.addEventListener('paste', handlePaste);
                return () => window.removeEventListener('paste', handlePaste);
            }, [handlePaste]);

            const handleDrop = (e) => {
                e.preventDefault();
                setIsDragging(false);
                if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        if (ev.target?.result) handleImageLoad(ev.target.result);
                    };
                    reader.readAsDataURL(e.dataTransfer.files[0]);
                }
            };

            // --- Image Processing ---

            const processImage = useCallback(async () => {
                if (!originalImage || !canvasRef.current) return;
                setIsProcessing(true);
                setTimeout(() => {
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    if (!ctx) return;
                    const aspectRatio = originalImage.height / originalImage.width;
                    const finalWidth = Math.round(targetWidth);
                    const finalHeight = maintainAspect ? Math.round(targetWidth * aspectRatio) : Math.round(originalImage.height * (targetWidth / originalImage.width));
                    canvas.width = finalWidth;
                    canvas.height = finalHeight;
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(originalImage, 0, 0, finalWidth, finalHeight);
                    const rawData = ctx.getImageData(0, 0, finalWidth, finalHeight);
                    const quantizedData = quantizeColors(rawData, colorCount);
                    ctx.putImageData(quantizedData, 0, 0);
                    setProcessedImageSrc(canvas.toDataURL('image/png'));
                    setIsProcessing(false);
                }, 50);
            }, [originalImage, targetWidth, maintainAspect, colorCount]);

            useEffect(() => {
                if (originalImage) {
                    const timer = setTimeout(processImage, 200);
                    return () => clearTimeout(timer);
                }
            }, [processImage]);

            const downloadImage = () => {
                if (!processedImageSrc) return;
                const link = document.createElement('a');
                link.download = `Moodpx-${targetWidth}x-${colorCount}c.png`;
                link.href = processedImageSrc;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            // --- Zoom & Pan Handlers ---

            const handleFitToScreen = () => {
                if (!outputContainerRef.current || !originalImage) return;

                const container = outputContainerRef.current;
                const containerW = container.clientWidth;
                const containerH = container.clientHeight;

                // We are fitting the "output pixel" dimensions (targetWidth) to the container
                // But we also need to respect aspect ratio
                const aspectRatio = originalImage.height / originalImage.width;
                const logicalHeight = targetWidth * aspectRatio;

                const scaleX = (containerW - 40) / targetWidth; // 40px padding
                const scaleY = (containerH - 40) / logicalHeight;

                const fitZoom = Math.min(scaleX, scaleY, 20); // Cap max zoom

                setZoom(fitZoom);
                setPan({ x: 0, y: 0 });
            };

            const handleWheel = (e) => {
                if (!processedImageSrc) return;
                e.preventDefault();
                const scaleFactor = 0.1;
                const delta = e.deltaY > 0 ? -scaleFactor : scaleFactor;
                setZoom(prev => Math.min(Math.max(prev + delta, 0.1), 50));
            };

            const handleMouseDown = (e) => {
                if (!processedImageSrc) return;
                setIsPanning(true);
                lastMousePos.current = { x: e.clientX, y: e.clientY };
            };

            const handleMouseMove = (e) => {
                if (!isPanning) return;
                e.preventDefault();
                const deltaX = e.clientX - lastMousePos.current.x;
                const deltaY = e.clientY - lastMousePos.current.y;
                setPan(prev => ({ x: prev.x + deltaX, y: prev.y + deltaY }));
                lastMousePos.current = { x: e.clientX, y: e.clientY };
            };

            const handleMouseUp = () => setIsPanning(false);
            const handleMouseLeave = () => setIsPanning(false);

            // Touch Handlers for Mobile (Pinch & Pan)
            const handleTouchStart = (e) => {
                if (!processedImageSrc) return;
                if (e.touches.length === 1) {
                    // Pan start
                    setIsPanning(true);
                    lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    // Pinch start
                    const dist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    lastTouchDistance.current = dist;
                }
            };

            const handleTouchMove = (e) => {
                if (!processedImageSrc) return;

                // Panning (1 finger)
                if (e.touches.length === 1 && isPanning) {
                    // e.preventDefault();
                    const deltaX = e.touches[0].clientX - lastMousePos.current.x;
                    const deltaY = e.touches[0].clientY - lastMousePos.current.y;
                    setPan(prev => ({ x: prev.x + deltaX, y: prev.y + deltaY }));
                    lastMousePos.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                // Pinch Zooming (2 fingers)
                else if (e.touches.length === 2 && lastTouchDistance.current !== null) {
                    // e.preventDefault();
                    const dist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const delta = dist - lastTouchDistance.current;
                    const sensitivity = 0.05; // increased sensitivity for mobile
                    setZoom(prev => Math.min(Math.max(prev + (delta * sensitivity), 0.1), 50));
                    lastTouchDistance.current = dist;
                }
            };

            const handleTouchEnd = () => {
                setIsPanning(false);
                lastTouchDistance.current = null;
            };

            return (
                <div className="min-h-screen bg-black text-zinc-300 font-sans flex flex-col selection:bg-zinc-700 selection:text-white touch-none">
                    <canvas ref={canvasRef} style={{ display: 'none' }} />

                    {/* Navbar */}
                    <nav className="border-b border-zinc-800 bg-black sticky top-0 z-20">
                        <div className="max-w-7xl mx-auto px-4 h-16 flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <div className="w-8 h-8 bg-zinc-100 rounded-lg flex items-center justify-center">
                                    <Layers className="w-5 h-5 text-black" />
                                </div>
                                <h1 className="text-xl font-bold text-white tracking-tight">Moodpx</h1>
                            </div>
                            <div className="text-xs text-zinc-500 font-medium border border-zinc-800 px-3 py-1 rounded-full hidden sm:block">
                                AI PIXEL ART FIXER
                            </div>
                        </div>
                    </nav>

                    <main className="flex-1 max-w-7xl mx-auto w-full p-4 lg:p-6 flex flex-col lg:flex-row gap-6 pb-24">

                        {/* LEFT COLUMN: Controls */}
                        <aside className="w-full lg:w-[340px] flex-shrink-0 flex flex-col gap-6 order-2 lg:order-1">

                            {/* File Input */}
                            <div
                                className={`
                                    relative group border border-dashed rounded-xl transition-all duration-200 cursor-pointer
                                    flex flex-col items-center justify-center text-center overflow-hidden bg-zinc-900/50
                                    ${isDragging ? 'border-zinc-400 bg-zinc-800' : 'border-zinc-800 hover:border-zinc-600'}
                                    ${!originalImage ? 'h-40' : 'h-20'}
                                `}
                                onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
                                onDragLeave={() => setIsDragging(false)}
                                onDrop={handleDrop}
                            >
                                <input
                                    type="file"
                                    accept="image/*"
                                    className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10"
                                    onChange={handleFileUpload}
                                />
                                <div className="flex flex-col items-center gap-2 pointer-events-none p-4">
                                    {originalImage ? (
                                        <div className="flex items-center gap-2 text-zinc-300">
                                            <RefreshCw className="w-4 h-4" />
                                            <span className="text-sm font-medium">Replace Image</span>
                                        </div>
                                    ) : (
                                        <>
                                            <Upload className="w-6 h-6 text-zinc-500 group-hover:text-zinc-300 transition-colors" />
                                            <div>
                                                <span className="text-sm font-medium text-zinc-300 block">Drop or Paste Image</span>
                                                <span className="text-[10px] uppercase tracking-wider text-zinc-600 mt-1 block">Supports PNG, JPG, WEBP</span>
                                            </div>
                                        </>
                                    )}
                                </div>
                            </div>

                            <div className={`flex flex-col gap-6 ${!originalImage ? 'opacity-40 pointer-events-none grayscale' : ''}`}>

                                {/* Grid Size Control */}
                                <div className="space-y-4">
                                    <div className="flex items-center justify-between text-zinc-400">
                                        <div className="flex items-center gap-2">
                                            <Maximize2 className="w-4 h-4" />
                                            <h3 className="text-xs font-bold uppercase tracking-wider">Output Size</h3>
                                        </div>
                                        <span className="text-xs font-mono bg-zinc-800 px-2 py-0.5 rounded text-white">{targetWidth}px</span>
                                    </div>

                                    <div className="grid grid-cols-5 gap-1.5">
                                        {PRESET_RESOLUTIONS.map((res) => (
                                            <button
                                                key={res.value}
                                                onClick={() => setTargetWidth(res.value)}
                                                className={`
                                                    px-1 py-2 text-[10px] font-medium rounded border transition-colors
                                                    ${targetWidth === res.value
                                                        ? 'bg-zinc-100 border-zinc-100 text-black'
                                                        : 'bg-zinc-900 border-zinc-800 text-zinc-500 hover:border-zinc-600 hover:text-zinc-300'}
                                                `}
                                            >
                                                {res.label.replace('px', '')}
                                            </button>
                                        ))}
                                    </div>

                                    <input
                                        type="range"
                                        min="16"
                                        max="512"
                                        step="8"
                                        value={targetWidth}
                                        onChange={(e) => setTargetWidth(parseInt(e.target.value))}
                                        className="w-full h-1.5 bg-zinc-800 rounded-lg appearance-none cursor-pointer accent-white"
                                    />
                                </div>

                                {/* Separator */}
                                <div className="h-px bg-zinc-800" />

                                {/* Color Palette Control */}
                                <div className="space-y-4">
                                    <div className="flex items-center justify-between text-zinc-400">
                                        <div className="flex items-center gap-2">
                                            <Palette className="w-4 h-4" />
                                            <h3 className="text-xs font-bold uppercase tracking-wider">Color Limit</h3>
                                        </div>
                                        <span className="text-xs font-mono bg-zinc-800 px-2 py-0.5 rounded text-white">{colorCount} Colors</span>
                                    </div>

                                    <div className="flex flex-wrap gap-2">
                                        {[4, 8, 16, 32, 64].map(count => (
                                            <button
                                                key={count}
                                                onClick={() => setColorCount(count)}
                                                className={`
                                                    h-8 px-3 rounded text-xs font-bold transition-all border
                                                    ${colorCount === count
                                                        ? 'bg-zinc-100 border-zinc-100 text-black'
                                                        : 'bg-black border-zinc-800 text-zinc-500 hover:border-zinc-600 hover:text-zinc-300'}
                                                `}
                                            >
                                                {count}
                                            </button>
                                        ))}
                                    </div>

                                    <input
                                        type="range"
                                        min="0"
                                        max={COLOR_COUNTS.length - 1}
                                        value={COLOR_COUNTS.indexOf(colorCount)}
                                        onChange={(e) => setColorCount(COLOR_COUNTS[parseInt(e.target.value)])}
                                        className="w-full h-1.5 bg-zinc-800 rounded-lg appearance-none cursor-pointer accent-white"
                                    />
                                </div>

                                {/* Action Button */}
                                <button
                                    onClick={downloadImage}
                                    disabled={!processedImageSrc}
                                    className="mt-4 w-full py-3 bg-white text-black rounded-lg font-bold hover:bg-zinc-200 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2 text-sm uppercase tracking-wide"
                                >
                                    <Download className="w-4 h-4" />
                                    Download PNG
                                </button>
                            </div>
                        </aside>


                        {/* RIGHT COLUMN: Viewport */}
                        <section className="flex-1 order-1 lg:order-2 h-[60vh] lg:h-auto min-h-[400px] bg-zinc-900/30 rounded-xl border border-zinc-800 flex flex-col overflow-hidden relative">
                            {!originalImage ? (
                                <div className="absolute inset-0 flex flex-col items-center justify-center text-zinc-600 gap-4 p-8 text-center">
                                    <ImageIcon className="w-12 h-12 opacity-20" />
                                    <p className="text-sm font-medium">Load an image to start processing</p>
                                </div>
                            ) : (
                                <div className="flex-1 relative flex flex-col h-full">
                                    {/* Viewport Header */}
                                    <div className="h-10 border-b border-zinc-800 flex items-center bg-zinc-900/80 backdrop-blur-sm z-10">
                                        <div className="flex-1 flex items-center px-4 border-r border-zinc-800 text-[10px] uppercase font-bold tracking-wider text-zinc-500">
                                            <div className="flex items-center gap-2">
                                                <div className="w-2 h-2 rounded-full bg-zinc-600"></div>
                                                Input
                                            </div>
                                        </div>
                                        <div className="flex-1 flex items-center justify-between px-4 text-[10px] uppercase font-bold tracking-wider text-zinc-500">
                                            <div className="flex items-center gap-2">
                                                <div className="w-2 h-2 rounded-full bg-white animate-pulse"></div>
                                                Output
                                            </div>

                                            <div className="flex items-center gap-2">

                                                {/* Zoom Controls */}
                                                <div className="flex items-center gap-1 bg-zinc-800/50 rounded p-0.5 ml-2 border border-zinc-700/50">
                                                    <button
                                                        onClick={handleFitToScreen}
                                                        title="Fit to Window"
                                                        className="p-1 hover:bg-zinc-700 rounded text-zinc-400 hover:text-white"
                                                    >
                                                        <Frame className="w-3 h-3" />
                                                    </button>
                                                    <button
                                                        onClick={() => { setZoom(1); setPan({x:0, y:0}); }}
                                                        title="Reset Zoom (1:1)"
                                                        className="p-1 hover:bg-zinc-700 rounded text-zinc-400 hover:text-white"
                                                    >
                                                        <ResetZoom className="w-3 h-3" />
                                                    </button>
                                                    <button
                                                        onClick={() => setZoom(z => Math.max(z - 0.5, 0.5))}
                                                        className="p-1 hover:bg-zinc-700 rounded text-zinc-400 hover:text-white"
                                                    >
                                                        <ZoomOut className="w-3 h-3" />
                                                    </button>
                                                    <span className="w-8 text-center font-mono text-[9px] text-zinc-300">
                                                        {Math.round(zoom * 100)}%
                                                    </span>
                                                    <button
                                                        onClick={() => setZoom(z => Math.min(z + 0.5, 50))}
                                                        className="p-1 hover:bg-zinc-700 rounded text-zinc-400 hover:text-white"
                                                    >
                                                        <ZoomIn className="w-3 h-3" />
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Split View */}
                                    <div className="flex-1 flex flex-col md:flex-row divide-y md:divide-y-0 md:divide-x divide-zinc-800 h-full overflow-hidden">

                                        {/* Original (Static Preview) */}
                                        <div className="flex-1 p-6 flex items-center justify-center bg-[url('https://www.transparenttextures.com/patterns/carbon-fibre.png')] bg-zinc-950 relative overflow-hidden group">
                                            <img
                                                src={originalSrc || ''}
                                                alt="Original"
                                                className="max-w-full max-h-full object-contain shadow-2xl"
                                                style={{ imageRendering: 'auto' }}
                                            />
                                            <span className="absolute bottom-2 left-2 text-[10px] bg-black/50 backdrop-blur text-white px-2 py-1 rounded border border-white/10 opacity-0 group-hover:opacity-100 transition-opacity">
                                                Original: {originalImage.width}x{originalImage.height}
                                            </span>
                                        </div>

                                        {/* Result (Zoomable/Pannable) */}
                                        <div
                                            ref={outputContainerRef}
                                            className={`flex-1 relative overflow-hidden bg-[url('https://www.transparenttextures.com/patterns/carbon-fibre.png')] bg-zinc-950 cursor-move ${isPanning ? 'cursor-grabbing' : ''}`}
                                            onWheel={handleWheel}
                                            onMouseDown={handleMouseDown}
                                            onMouseMove={handleMouseMove}
                                            onMouseUp={handleMouseUp}
                                            onMouseLeave={handleMouseLeave}
                                            onTouchStart={handleTouchStart}
                                            onTouchMove={handleTouchMove}
                                            onTouchEnd={handleTouchEnd}
                                        >
                                            {processedImageSrc && (
                                                <div
                                                    className="absolute inset-0 flex items-center justify-center origin-center pointer-events-none"
                                                >
                                                    <div
                                                        style={{
                                                            transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
                                                            transition: isPanning ? 'none' : 'transform 0.1s ease-out'
                                                        }}
                                                        className="relative shadow-2xl"
                                                    >
                                                        <img
                                                            src={processedImageSrc}
                                                            alt="Processed"
                                                            style={{
                                                                imageRendering: 'pixelated',
                                                                pointerEvents: 'none'
                                                            }}
                                                        />
                                                    </div>
                                                </div>
                                            )}

                                            {/* Stats Overlay */}
                                            <div className="absolute bottom-2 left-2 flex flex-col gap-1 pointer-events-none">
                                                <span className="text-[10px] bg-white/10 backdrop-blur text-white px-2 py-1 rounded border border-white/10">
                                                    Fixed: {targetWidth}px
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </section>

                    </main>

                    {/* Footer */}
                    <footer className="border-t border-zinc-900 bg-black py-4 px-6 fixed bottom-0 w-full z-30">
                        <div className="max-w-7xl mx-auto flex items-center justify-between">
                            <span className="text-xs font-mono text-zinc-500">
                                Moodpx Current stable version: v1.0.0
                            </span>
                            <div className="flex items-center gap-3">
                                <a href="https://www.patreon.com/cw/bdvd" className="w-8 h-8 rounded-full bg-zinc-900 flex items-center justify-center text-zinc-400 hover:bg-zinc-800 hover:text-white transition-all border border-zinc-800">
                                    <PatreonIcon className="w-3.5 h-3.5" />
                                </a>
                                <a href="https://linktr.ee/davidbrum" className="w-8 h-8 rounded-full bg-zinc-900 flex items-center justify-center text-zinc-400 hover:bg-zinc-800 hover:text-white transition-all border border-zinc-800">
                                    <LinkIcon className="w-3.5 h-3.5" />
                                </a>
                                <a href="https://github.com/davidbrum25/moodpx" className="w-8 h-8 rounded-full bg-zinc-900 flex items-center justify-center text-zinc-400 hover:bg-zinc-800 hover:text-white transition-all border border-zinc-800">
                                    <Github className="w-4 h-4" />
                                </a>
                            </div>
                        </div>
                    </footer>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<MoodpxApp />);
    </script>
</body>
</html>
